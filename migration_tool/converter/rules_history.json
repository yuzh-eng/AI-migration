[
  {
    "timestamp": "2025-12-22T06:16:02.420280",
    "trigger_sql": "SELECT NVL(TO_CHAR(ADD_MONTHS(TRUNC(SYSDATE, 'MM'), 6), 'YYYY-MM-DD'), 'DEFAULT_DATE') AS adjusted_date,\n       NVL2(LAST_DAY(TO_DATE('2023-02-15', 'YYYY-MM-DD')), \n            TO_CHAR(NEXT_DAY(LAST_DAY(TO_DATE('2023-02-15', 'YYYY-MM-DD')), 'MONDAY'), 'Day, DD Month YYYY'), \n            'NO_LAST_DAY') AS next_monday_after_last_day,\n       COALESCE(TO_CHAR(FIRST_VALUE(HIREDATE) OVER (ORDER BY HIREDATE ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 'DD-MON-YYYY'),\n                TO_CHAR(SYSDATE, 'DD-MON-YYYY')) AS first_hire_or_today,\n       NVL(TO_CHAR(NULLIF(MONTHS_BETWEEN(SYSDATE, TO_DATE('1990-01-01', 'YYYY-MM-DD')), 0), 'FM999.00'), 'NO_MONTHS') AS months_diff\nFROM EMPLOYEES\nWHERE ROWNUM = 1;",
    "before_conversion": "SELECT COALESCE(TO_CHAR(DATEADD(month, CURRENT_TIMESTAMP(, DATE_TRUNC('day'), 'MM'), 6), 'YYYY-MM-DD'), 'DEFAULT_DATE') AS adjusted_date,\n       IFF(LAST_DAY(TO_DATE('2023-02-15' IS NOT NULL, 'YYYY-MM-DD')), TO_VARCHAR(NEXT_DAY(LAST_DAY(TO_DATE('2023-02-15', 'YYYY-MM-DD')), 'MONDAY'), 'Day, DD Month YYYY'), \n            'NO_LAST_DAY') AS next_monday_after_last_day,\n       COALESCE(TO_VARCHAR(FIRST_VALUE(HIREDATE) OVER (ORDER BY HIREDATE ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), 'DD-MON-YYYY'),\n                TO_VARCHAR(CURRENT_TIMESTAMP(), 'DD-MON-YYYY')) AS first_hire_or_today,\n       COALESCE(TO_CHAR(NULLIF(MONTHS_BETWEEN(CURRENT_TIMESTAMP(), TO_DATE('1990-01-01', 'YYYY-MM-DD')), 0), 'FM999.00'), 'NO_MONTHS') AS months_diff\nFROM EMPLOYEES\nWHERE ROWNUM = 1;",
    "issues": [
      "Incorrect use of DATEADD and DATE_TRUNC: DATEADD(month, CURRENT_TIMESTAMP(, DATE_TRUNC('day'), 'MM'), 6) has syntax errors — misplaced parentheses and incorrect nesting.",
      "DATE_TRUNC('day') is used incorrectly; should be DATE_TRUNC('month', CURRENT_DATE()) to match Oracle's TRUNC(SYSDATE, 'MM').",
      "CURRENT_TIMESTAMP() is used instead of CURRENT_DATE() in some contexts, leading to potential timestamp vs date mismatches.",
      "SYSDATE is replaced with CURRENT_TIMESTAMP(), but should typically be replaced with CURRENT_DATE() or SYSDATE equivalent in Snowflake (e.g., CURRENT_DATE).",
      "The expression TO_DATE('2023-02-15' IS NOT NULL, 'YYYY-MM-DD') is invalid syntax — 'IS NOT NULL' inside TO_DATE is not valid.",
      "IFF condition uses LAST_DAY(...) IS NOT NULL logic incorrectly — LAST_DAY always returns a date; the check is redundant and misapplied.",
      "NVL and NVL2 are replaced inconsistently: NVL is replaced by COALESCE correctly, but NVL2 usage is replaced with IFF, yet the condition is wrong.",
      "NEXT_DAY function in Snowflake expects day of week as number or string like 'Monday', but input 'MONDAY' may need to be lowercase or consistent with locale; also, formatting with 'Day, DD Month YYYY' may not render as expected.",
      "TO_CHAR with format 'FM999.00' uses Oracle-specific FM format; Snowflake uses different formatting (e.g., via FORMAT function or compatible patterns), which is not handled.",
      "ROWNUM is used in Snowflake — Snowflake does not support ROWNUM; should use LIMIT 1 instead.",
      "Function MONTHS_BETWEEN exists in Snowflake but behavior may differ slightly from Oracle; however, usage appears acceptable if arguments are correct.",
      "Use of TO_VARCHAR instead of TO_CHAR is correct in Snowflake, but inconsistent — some still use TO_CHAR (which is not valid in Snowflake); must use TO_VARCHAR."
    ],
    "proposed_rule": {
      "type": "regex",
      "pattern": "NVL\\(([^,]+),\\s*([^)]+)\\)",
      "repl": "COALESCE($1, $2)"
    },
    "applied": false
  },
  {
    "timestamp": "2025-12-22T06:29:04.333697",
    "trigger_sql": "SELECT /*+ LEADING(e) USE_NL(d) */ \n       e.employee_id,\n       e.first_name,\n       e.last_name,\n       d.department_name,\n       NVL(TO_CHAR(e.commission_pct, 'FM90D00%'), 'N/A') AS commission_formatted,\n       CASE \n         WHEN e.salary > (SELECT AVG(salary) FROM employees WHERE department_id = e.department_id) \n         THEN 'Above Avg'\n         ELSE 'Below Avg'\n       END AS salary_level,\n       ROW_NUMBER() OVER (PARTITION BY e.department_id ORDER BY e.salary DESC NULLS LAST) AS rank_in_dept,\n       LAG(e.hire_date, 1, DATE '1900-01-01') IGNORE NULLS OVER (ORDER BY e.hire_date) AS prev_hire_date,\n       RTRIM(XMLCAST(XMLAGG(XMLELEMENT(E, e.first_name || ', ') ORDER BY e.last_name) AS XMLTYPE).GETCLOBVAL(), ', ') AS names_list\nFROM   employees e\n       INNER JOIN departments d ON e.department_id = d.department_id\n       LEFT JOIN locations l ON d.location_id = l.location_id AND l.country_id = 'US'\nWHERE  e.hire_date BETWEEN ADD_MONTHS(TRUNC(SYSDATE, 'YEAR'), -12) AND SYSDATE\n  AND  REGEXP_LIKE(e.email, '^[A-Z]{3}[0-9]{3}$')\n  AND  e.manager_id IS NOT NULL\nCONNECT BY PRIOR e.employee_id = e.manager_id\nSTART WITH e.manager_id IS NULL\nORDER BY e.department_id, rank_in_dept;",
    "before_conversion": "SELECT /*+ LEADING(e) USE_NL(d) */ \n       e.employee_id,\n       e.first_name,\n       e.last_name,\n       d.department_name,\n       COALESCE(TO_VARCHAR(e.commission_pct, 'FM90D00%'), 'N/A') AS commission_formatted,\n       CASE \n         WHEN e.salary > (SELECT AVG(salary) FROM employees WHERE department_id = e.department_id) \n         THEN 'Above Avg'\n         ELSE 'Below Avg'\n       END AS salary_level,\n       ROW_NUMBER() OVER (PARTITION BY e.department_id ORDER BY e.salary DESC NULLS LAST) AS rank_in_dept,\n       LAG(e.hire_date, 1, TIMESTAMP_NTZ '1900-01-01') IGNORE NULLS OVER (ORDER BY e.hire_date) AS prev_hire_date,\n       RTRIM(XMLCAST(XMLAGG(XMLELEMENT(E, e.first_name || ', ') ORDER BY e.last_name) AS XMLTYPE).GETCLOBVAL(), ', ') AS names_list\nFROM   employees e\n       INNER JOIN departments d ON e.department_id = d.department_id\n       LEFT JOIN locations l ON d.location_id = l.location_id AND l.country_id = 'US'\nWHERE  e.hire_date BETWEEN DATEADD(month, CURRENT_TIMESTAMP(, DATE_TRUNC('day'), 'YEAR'), -12) AND CURRENT_TIMESTAMP()\n  AND  REGEXP_LIKE(e.email, '^[A-Z]{3}[0-9]{3}$')\n  AND  e.manager_id IS NOT NULL\nCONNECT BY PRIOR e.employee_id = e.manager_id\nSTART WITH e.manager_id IS NULL\nORDER BY e.department_id, rank_in_dept;",
    "issues": [
      "Incorrect conversion of ADD_MONTHS(TRUNC(SYSDATE, 'YEAR'), -12) to DATEADD: The Snowflake version uses CURRENT_TIMESTAMP(, DATE_TRUNC('day'), 'YEAR') which is syntactically invalid. It should be DATE_TRUNC('year', CURRENT_DATE()) and then DATEADD(month, -12, ...).",
      "SYSDATE in Oracle is equivalent to CURRENT_DATE or CURRENT_TIMESTAMP depending on context; here it's used with date arithmetic so CURRENT_DATE would be more appropriate.",
      "The XMLAGG/XMLCAST/GETCLOBVAL pattern for string aggregation is not supported in Snowflake. Snowflake uses LISTAGG for this purpose instead of Oracle's XML-based concatenation.",
      "Snowflake does not support CONNECT BY syntax for hierarchical queries. It must be replaced with a recursive CTE.",
      "The LAG function with IGNORE NULLS is not supported in Snowflake. Snowflake supports IGNORE NULLS in some window functions but not in LAG as of current versions.",
      "Use of TIMESTAMP_NTZ '1900-01-01' is valid but may cause issues because LAG with IGNORE NULLS isn't supported; also, mixing NTZ with no time component is inconsistent.",
      "The REGEXP_LIKE usage is correct, but note that Snowflake's REGEXP_LIKE is case-sensitive by default, same as Oracle, so no issue there.",
      "NVL was correctly changed to COALESCE, but the original comment mentioned keeping NVL — this one was actually fixed.",
      "RTRIM(XMLCAST(...).GETCLOBVAL(), ', ') uses Oracle-specific XML-to-string logic which has no direct equivalent in Snowflake and will fail.",
      "The hint /*+ LEADING(e) USE_NL(d) */ is ignored in Snowflake as query hints are not supported."
    ],
    "proposed_rule": {
      "type": "regex",
      "pattern": "RTRIM\\(XMLCAST\\(XMLAGG\\(XMLELEMENT\\(E,([^)]+)\\) ORDER BY([^)]+)\\) AS XMLTYPE\\)\\.GETCLOBVAL\\(\\), '([^']*)'\\)",
      "repl": "LISTAGG$1$2, '$3') WITHIN GROUP $2"
    },
    "applied": false
  },
  {
    "timestamp": "2025-12-22T07:04:26.961029",
    "trigger_sql": "SELECT NVL(TO_CHAR(ADD_MONTHS(TRUNC(SYSDATE, 'MM'), -1), 'YYYY-MM-DD'), 'No Date Available') AS previous_month_start,\n       NVL2(LAST_DAY(TO_DATE('2023-02-15', 'YYYY-MM-DD')), \n            TO_CHAR(LAST_DAY(TO_DATE('2023-02-15', 'YYYY-MM-DD')), 'Day, DD Month YYYY', 'NLS_DATE_LANGUAGE = American'), \n            'Invalid Date') AS last_day_of_month,\n       COALESCE(\n         CASE WHEN EXTRACT(DAY FROM SYSDATE) > 15 THEN TRUNC(SYSDATE, 'Q') ELSE ADD_MONTHS(TRUNC(SYSDATE, 'Q'), -3) END,\n         SYSDATE\n       ) AS adjusted_quarter_start,\n       NVL(TO_CHAR(\n             CASE \n               WHEN MOD(EXTRACT(YEAR FROM SYSDATE), 4) = 0 THEN NEXT_DAY(SYSDATE, 'SATURDAY')\n               ELSE LAST_DAY(ADD_MONTHS(SYSDATE, 6))\n             END, 'DD-MON-YYYY HH24:MI:SS'\n           ), 'Processing Error') AS conditional_future_date\nFROM DUAL\nCONNECT BY LEVEL <= 1;",
    "before_conversion": "SELECT COALESCE(TO_CHAR(DATEADD(month, CURRENT_TIMESTAMP(, DATE_TRUNC('day'), 'MM'), -1), 'YYYY-MM-DD'), 'No TIMESTAMP_NTZ Available') AS previous_month_start,\n       IFF(LAST_DAY(TO_DATE('2023-02-15' IS NOT NULL, 'YYYY-MM-DD')), TO_VARCHAR(LAST_DAY(TO_DATE('2023-02-15', 'YYYY-MM-DD')), 'Day, DD Month YYYY', 'NLS_DATE_LANGUAGE = American'), \n            'Invalid TIMESTAMP_NTZ') AS last_day_of_month,\n       COALESCE(\n         CASE WHEN EXTRACT(DAY FROM CURRENT_TIMESTAMP()) > 15 THEN DATE_TRUNC('day', CURRENT_TIMESTAMP(), 'Q') ELSE DATEADD(month, CURRENT_TIMESTAMP(, DATE_TRUNC('day'), 'Q'), -3) END,\n         CURRENT_TIMESTAMP()\n       ) AS adjusted_quarter_start,\n       COALESCE(TO_CHAR(\n             CASE \n               WHEN MOD(EXTRACT(YEAR FROM CURRENT_TIMESTAMP()), 4) = 0 THEN NEXT_DAY(CURRENT_TIMESTAMP(), 'SATURDAY')\n               ELSE LAST_DAY(DATEADD(month, 6, CURRENT_TIMESTAMP()))\n             END, 'DD-MON-YYYY HH24:MI:SS'\n           ), 'Processing Error') AS conditional_future_date\n\nCONNECT BY LEVEL <= 1;",
    "issues": [
      "Incorrect use of CURRENT_TIMESTAMP() with extra parentheses and invalid syntax in DATEADD and DATE_TRUNC functions.",
      "Invalid expression 'CURRENT_TIMESTAMP(, DATE_TRUNC('day'), 'MM')' – malformed and syntactically incorrect.",
      "DATE_TRUNC function misused: correct syntax is DATE_TRUNC('month', <timestamp>) not DATE_TRUNC('day', <timestamp>, 'MM').",
      "DATEADD function used incorrectly: should be DATEADD(month, -1, <date>) but is written as DATEADD(month, CURRENT_TIMESTAMP(, ...), -1).",
      "Use of 'IS NOT NULL' inside IFF condition on a static date string is incorrect; TO_DATE('2023-02-15', 'YYYY-MM-DD') will never be null.",
      "NLS_DATE_LANGUAGE parameter in TO_VARCHAR is not supported in Snowflake; localization should use session parameters or separate formatting logic.",
      "The 'CONNECT BY LEVEL <= 1' clause is Oracle-specific and not valid in Snowflake; should be replaced with a generator or removed if only one row is needed.",
      "Replaced 'NVL' with COALESCE correctly, but other NVL2 usage was changed to IFF, which is correct, however the logic was broken in translation.",
      "Output literal 'No TIMESTAMP_NTZ Available' and 'Invalid TIMESTAMP_NTZ' incorrectly reference 'TIMESTAMP_NTZ' instead of 'Date', misleading and inconsistent with Oracle's intent.",
      "NEXT_DAY function in Snowflake expects day name like 'SATURDAY' but is case-sensitive and requires proper locale setup; also, behavior may differ slightly from Oracle.",
      "MOD(EXTRACT(YEAR FROM CURRENT_TIMESTAMP()), 4) = 0 does not correctly determine leap years (not equivalent to Oracle's logic for leap year handling).",
      "Missing FROM clause in Snowflake query; Oracle's DUAL is not required but Snowflake requires a FROM source if not using standalone expressions."
    ],
    "proposed_rule": {
      "type": "regex",
      "pattern": "(NVL\\()([^,]+),\\s*('(?:[^']|'')*')\\)",
      "repl": "COALESCE($2, $3)"
    },
    "applied": false
  },
  {
    "timestamp": "2025-12-23T02:13:37.044463",
    "trigger_sql": "SELECT \n    TO_CHAR(SYSTIMESTAMP AT TIME ZONE 'UTC', 'YYYY-MM-DD\"T\"HH24:MI:SS.FF3TZH:TZM') AS utc_timestamp_formatted,\n    TO_TIMESTAMP_TZ('2023-12-25 14:30:00 -05:00', 'YYYY-MM-DD HH24:MI:SS TZH:TZM') AT TIME ZONE SESSIONTIMEZONE AS local_xmas_event,\n    NEW_TIME(TO_DATE('2023-07-04 12:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'PST', 'EST') AS converted_date_legacy,\n    FROM_TZ(CAST(TO_DATE('2023-11-01 09:15:30', 'YYYY-MM-DD HH24:MI:SS') AS TIMESTAMP), 'America/New_York') AS tz_enabled_timestamp,\n    ROUND(SYSDATE + INTERVAL '3.5' HOUR, 'HH') AS rounded_to_nearest_hour,\n    TRUNC(CURRENT_TIMESTAMP, 'IW') + INTERVAL '6' DAY AS end_of_week_timestamp,\n    EXTRACT(DOW FROM SYSDATE) AS day_of_week_numeric,\n    LAST_DAY(ADD_MONTHS(SYSDATE, 6)) AS last_day_six_months_ahead,\n    CASE \n        WHEN CURRENT_DATE - DATE '2023-01-01' BETWEEN 0 AND 365 \n        THEN 'Within Year'\n        ELSE 'Outside Year'\n    END AS date_range_check,\n    TO_CHAR(\n        CAST(\n            FROM_TZ(\n                TO_TIMESTAMP('2023-08-15 10:20:30.456', 'YYYY-MM-DD HH24:MI:SS.FF3'),\n                'Australia/Sydney'\n            ) AT TIME ZONE 'Europe/Paris' \n        AS DATE),\n        'DD-MON-YYYY HH24:MI:SS'\n    ) AS cross_tz_conversion_to_date\nFROM DUAL\nCONNECT BY LEVEL <= 1\nUNION ALL\nSELECT \n    TO_CHAR(\n        TIMESTAMP '2023-03-10 02:30:00' AT LOCAL, \n        'YYYY-MM-DD HH24:MI:SS TZR'\n    ) AS daylight_savings_transition_test,\n    LAG(TO_TIMESTAMP('2023-01-01 00:00:00', 'YYYY-MM-DD HH24:MI:SS')) OVER (ORDER BY NULL) AS previous_event_time,\n    TO_TIMESTAMP_TZ('2023-06-15 18:45:00 UTC', 'YYYY-MM-DD HH24:MI:SS TZR') + NUMTODSINTERVAL(7.25, 'DAY') AS future_tz_aware_event,\n    GREATEST(\n        SYSTIMESTAMP,\n        TO_TIMESTAMP_TZ('2023-01-01 00:00:00 UTC', 'YYYY-MM-DD HH24:MI:SS TZR')\n    ) AS latest_timestamp_with_tz,\n    SESSIONTIMEZONE AS session_timezone,\n    DBTIMEZONE AS db_timezone,\n    CURRENT_DATE AS current_session_date,\n    CURRENT_TIMESTAMP AS current_timestamp_with_tz,\n    LOCALTIMESTAMP AS local_timestamp_no_tz\nFROM DUAL;",
    "before_conversion": "SELECT \n    TO_VARCHAR(CURRENT_TIMESTAMP() AT TIME ZONE 'UTC', 'YYYY-MM-DD\"T\"HH24:MI:SS.FF3TZH:TZM') AS utc_timestamp_formatted,\n    TO_TIMESTAMP_TZ('2023-12-25 14:30:00 -05:00', 'YYYY-MM-DD HH24:MI:SS TZH:TZM') AT TIME ZONE SESSIONTIMEZONE AS local_xmas_event,\n    NEW_TIME(TO_DATE('2023-07-04 12:00:00', 'YYYY-MM-DD HH24:MI:SS'), 'PST', 'EST') AS converted_date_legacy,\n    FROM_TZ(CAST(TO_DATE('2023-11-01 09:15:30', 'YYYY-MM-DD HH24:MI:SS') AS TIMESTAMP), 'America/New_York') AS tz_enabled_timestamp,\n    ROUND(CURRENT_TIMESTAMP() + INTERVAL '3.5' HOUR, 'HH') AS rounded_to_nearest_hour,\n    TRUNC(CURRENT_TIMESTAMP, 'IW') + INTERVAL '6' DAY AS end_of_week_timestamp,\n    EXTRACT(DOW FROM CURRENT_TIMESTAMP()) AS day_of_week_numeric,\n    LAST_DAY(DATEADD(month, 6, CURRENT_TIMESTAMP())) AS last_day_six_months_ahead,\n    CASE \n        WHEN CURRENT_DATE - TIMESTAMP_NTZ '2023-01-01' BETWEEN 0 AND 365 \n        THEN 'Within Year'\n        ELSE 'Outside Year'\n    END AS date_range_check,\n    TO_VARCHAR(CAST(\n            FROM_TZ(\n                TO_TIMESTAMP('2023-08-15 10:20:30.456', 'YYYY-MM-DD HH24:MI:SS.FF3'),\n                'Australia/Sydney'\n            ) AT TIME ZONE 'Europe/Paris' \n        AS TIMESTAMP_NTZ),\n        'DD-MON-YYYY HH24:MI:SS'\n    ) AS cross_tz_conversion_to_date\n\nCONNECT BY LEVEL <= 1\nUNION ALL\nSELECT \n    TO_VARCHAR(TIMESTAMP '2023-03-10 02:30:00' AT LOCAL, 'YYYY-MM-DD HH24:MI:SS TZR') AS daylight_savings_transition_test,\n    LAG(TO_TIMESTAMP('2023-01-01 00:00:00', 'YYYY-MM-DD HH24:MI:SS')) OVER (ORDER BY NULL) AS previous_event_time,\n    TO_TIMESTAMP_TZ('2023-06-15 18:45:00 UTC', 'YYYY-MM-DD HH24:MI:SS TZR') + NUMTODSINTERVAL(7.25, 'DAY') AS future_tz_aware_event,\n    GREATEST(\n        CURRENT_TIMESTAMP(),\n        TO_TIMESTAMP_TZ('2023-01-01 00:00:00 UTC', 'YYYY-MM-DD HH24:MI:SS TZR')\n    ) AS latest_timestamp_with_tz,\n    SESSIONTIMEZONE AS session_timezone,\n    DBTIMEZONE AS db_timezone,\n    CURRENT_DATE AS current_session_date,\n    CURRENT_TIMESTAMP AS current_timestamp_with_tz,\n    LOCALTIMESTAMP AS local_timestamp_no_tz\n;",
    "issues": [
      "Missing FROM clause in the first SELECT block: Snowflake requires a FROM clause even if generating data without a table (e.g., FROM DUAL or using VALUES). The original Oracle uses FROM DUAL, but the Snowflake version omits it after the CONNECT BY.",
      "CONNECT BY LEVEL <= 1 is not valid in Snowflake unless used with a hierarchical query or emulated via a generator. Snowflake does not support Oracle's CONNECT BY syntax directly; should use GENERATOR or a CTE with SEQUENCE.",
      "SYSDATE in Oracle was replaced inconsistently: some instances use CURRENT_TIMESTAMP(), others CURRENT_DATE — while this is often acceptable, SYSDATE maps more closely to CURRENT_DATE for date-only usage, but TIMESTAMP context needs care.",
      "ROUND function with 'HH' as format is not supported in Snowflake. Snowflake's ROUND for timestamps only supports units like 'HOUR', not 'HH'. Should be 'HOUR' instead of 'HH'.",
      "LAST_DAY(DATEADD(month, 6, CURRENT_TIMESTAMP())) may return incorrect result because LAST_DAY operates on date parts but CURRENT_TIMESTAMP() includes time and timezone. Should cast to DATE or use appropriate truncation.",
      "NUMTODSINTERVAL(7.25, 'DAY') is not supported in Snowflake. Use INTERVAL '7.25' DAY or equivalent TIMEADD/DATEADD with fractional seconds manually handled.",
      "NEW_TIME function is not available in Snowflake. This is an Oracle-specific function; must be rewritten using time zone conversion logic via CONVERT_TIMEZONE or manual offset handling.",
      "FROM_TZ with a string timezone like 'America/New_York' is not directly supported in Snowflake. FROM_TZ expects a timestamp and a time zone offset, not IANA names. Use of IANA zones requires session time zone settings or alternative pattern.",
      "CAST(... AS TIMESTAMP_NTZ) inside TO_VARCHAR may lose time zone information prematurely. The cross_tz_conversion_to_date logic converts to TIMESTAMP_NTZ which strips TZ before formatting, potentially losing correct TZ behavior.",
      "DBTIMEZONE and SESSIONTIMEZONE are not directly available in Snowflake. These are Oracle-specific. Snowflake uses CURRENT_AVAILABLE_ROLES, or session context functions like CURRENT_SESSION(), but no direct equivalents. Likely causes runtime error.",
      "Use of AT LOCAL in Snowflake: TIMESTAMP '2023-03-10 02:30:00' AT LOCAL is not valid syntax in Snowflake. AT LOCAL is Oracle-specific; Snowflake uses time zone conversion via CONVERT_TIMEZONE or session context.",
      "Lack of DUAL emulation: While Snowflake allows scalar expressions, best practice is to use FROM (VALUES (NULL)) or similar when expecting dual-like behavior, especially with window functions."
    ],
    "proposed_rule": {
      "type": "regex",
      "pattern": "(ROUND\\([^,]+,\\s*)'HH'(?=\\))",
      "repl": "\\1'HOUR'"
    },
    "applied": false
  },
  {
    "timestamp": "2025-12-23T03:08:22.403201",
    "trigger_sql": "SELECT /*+ LEADING(e) USE_NL(d) */ \n       e.employee_id,\n       e.first_name,\n       e.last_name,\n       d.department_name,\n       NVL(TO_CHAR(COMM, 'L999G999D99', 'NLS_NUMERIC_CHARACTERS='',.'' NLS_CURRENCY=''€'''), 'Not Applicable') AS formatted_comm,\n       CASE \n           WHEN e.salary > (SELECT AVG(salary) * 1.2 FROM employees WHERE department_id = e.department_id) \n           THEN 'High Earner'\n           ELSE 'Standard'\n       END AS salary_level,\n       ROW_NUMBER() OVER (PARTITION BY e.department_id ORDER BY e.salary DESC NULLS LAST) AS rank_in_dept,\n       LAG(e.hire_date, 1, DATE '1900-01-01') IGNORE NULLS OVER (ORDER BY e.employee_id) AS prev_hire_date,\n       XMLCAST(XMLQUERY('/employee/age/text()' PASSING XMLTYPE('<employee><age>35</age></employee>') RETURNING CONTENT) AS NUMBER) AS extracted_age\nFROM employees e\nJOIN departments d ON e.department_id = d.department_id\nWHERE e.hire_date BETWEEN ADD_MONTHS(TRUNC(SYSDATE, 'YEAR'), -12) AND SYSDATE\n  AND EXISTS (\n      SELECT 1 \n      FROM dual \n      CONNECT BY LEVEL <= 3\n      MINUS\n      SELECT 1 FROM bonuses b WHERE b.employee_id = e.employee_id\n  )\nORDER BY e.department_id, rank_in_dept;",
    "before_conversion": "SELECT /*+ LEADING(e) USE_NL(d) */ \n       e.employee_id,\n       e.first_name,\n       e.last_name,\n       d.department_name,\n       COALESCE(TO_CHAR(COMM, 'L999G999D99', 'NLS_NUMERIC_CHARACTERS='',.'' NLS_CURRENCY=''€'''), 'Not Applicable') AS formatted_comm,\n       CASE \n           WHEN e.salary > (SELECT AVG(salary) * 1.2 FROM employees WHERE department_id = e.department_id) \n           THEN 'High Earner'\n           ELSE 'Standard'\n       END AS salary_level,\n       ROW_NUMBER() OVER (PARTITION BY e.department_id ORDER BY e.salary DESC NULLS LAST) AS rank_in_dept,\n       LAG(e.hire_date, 1, TIMESTAMP_NTZ '1900-01-01') IGNORE NULLS OVER (ORDER BY e.employee_id) AS prev_hire_date,\n       XMLCAST(XMLQUERY('/employee/age/text()' PASSING XMLTYPE('<employee><age>35</age></employee>') RETURNING CONTENT) AS NUMBER) AS extracted_age\nFROM employees e\nJOIN departments d ON e.department_id = d.department_id\nWHERE e.hire_date BETWEEN DATEADD(month, CURRENT_TIMESTAMP(, DATE_TRUNC('day'), 'YEAR'), -12) AND CURRENT_TIMESTAMP()\n  AND EXISTS (\n      SELECT 1 \n       \n      CONNECT BY LEVEL <= 3\n      MINUS\n      SELECT 1 FROM bonuses b WHERE b.employee_id = e.employee_id\n  )\nORDER BY e.department_id, rank_in_dept;",
    "issues": [
      "Incorrect usage of DATEADD and DATE_TRUNC in WHERE clause: 'DATEADD(month, CURRENT_TIMESTAMP(, DATE_TRUNC('day'), 'YEAR'), -12)' has malformed syntax and incorrect function nesting.",
      "SYSDATE converted incorrectly: Oracle's TRUNC(SYSDATE, 'YEAR') should map to DATE_TRUNC('year', CURRENT_DATE) in Snowflake, not involving CURRENT_TIMESTAMP with incorrect parameters.",
      "The CONNECT BY LEVEL query is invalid in Snowflake; hierarchical queries using CONNECT BY are not supported and must be replaced with alternative approaches like recursive CTEs or generator functions.",
      "MINUS operator used in EXISTS subquery is not supported in Snowflake; should be replaced with EXCEPT.",
      "XMLTYPE function is Oracle-specific and not directly supported in Snowflake; XML handling requires different approach using Snowflake's XMLPARSE or direct string-to-XML casting.",
      "The LAG function uses IGNORE NULLS which is syntactically allowed in Snowflake but behavior may differ; however, the default is IGNORE NULLS so it's acceptable, but TIMESTAMP_NTZ '1900-01-01' should use proper TO_TIMESTAMP_LTZ or standard casting.",
      "NVL was correctly replaced with COALESCE, which is acceptable in Snowflake.",
      "The hint /*+ LEADING(e) USE_NL(d) */ is Oracle-specific and ignored in Snowflake; while not an error, it has no effect and should be removed or commented out."
    ],
    "proposed_rule": {
      "type": "regex",
      "pattern": "TRUNC\\(SYSDATE,\\s*'YEAR'\\)",
      "repl": "DATE_TRUNC('year', CURRENT_DATE)"
    },
    "applied": false
  },
  {
    "timestamp": "2025-12-23T09:13:33.700321",
    "trigger_sql": "SELECT /*+ LEADING(e) USE_NL(d) */ \n       e.employee_id,\n       e.first_name,\n       e.last_name,\n       d.department_name,\n       NVL(TO_CHAR(LAG(e.hire_date, 1) OVER (PARTITION BY d.department_id ORDER BY e.hire_date), 'DD-MON-YYYY'), 'No Prior Hire') AS prev_hire_date,\n       CASE \n           WHEN e.salary > (SELECT AVG(salary) FROM employees WHERE department_id = e.department_id) \n           THEN 'Above Avg'\n           ELSE 'Below Avg'\n       END AS salary_level,\n       DECODE(SIGN(e.commission_pct - 0.2), 1, 'High', 0, 'Medium', -1, 'Low', 'None') AS commission_category,\n       RANK() OVER (PARTITION BY e.job_id ORDER BY e.salary DESC NULLS LAST) AS salary_rank_in_job,\n       DENSE_RANK() OVER (ORDER BY SUM(e.salary) OVER (PARTITION BY d.location_id) DESC) AS location_comp_rank\nFROM employees e\nNATURAL JOIN departments d\nJOIN locations l ON d.location_id = l.location_id\nWHERE e.hire_date BETWEEN DATE '2000-01-01' AND DATE '2023-12-31'\n  AND EXISTS (\n      SELECT 1 \n      FROM job_history jh \n      WHERE jh.employee_id = e.employee_id \n        AND jh.department_id = d.department_id\n        AND ROWNUM = 1\n  )\n  AND e.employee_id IN (\n      SELECT employee_id \n      FROM (\n          SELECT employee_id, ROW_NUMBER() OVER (ORDER BY hire_date) rn \n          FROM employees \n          WHERE department_id IS NOT NULL\n      ) \n      WHERE rn <= 50\n  )\nORDER BY d.department_name ASC NULLS FIRST, e.last_name DESC NULLS LAST;",
    "before_conversion": "SELECT /*+ LEADING(e) USE_NL(d) */ \n       e.employee_id,\n       e.first_name,\n       e.last_name,\n       d.department_name,\n       COALESCE(TO_CHAR(LAG(e.hire_date, 1) OVER (PARTITION BY d.department_id ORDER BY e.hire_date), 'DD-MON-YYYY'), 'No Prior Hire') AS prev_hire_date,\n       CASE \n           WHEN e.salary > (SELECT AVG(salary) FROM employees WHERE department_id = e.department_id) \n           THEN 'Above Avg'\n           ELSE 'Below Avg'\n       END AS salary_level,\n       CASE WHEN SIGN(e.commission_pct - 0.2)=1 THEN 'High' ELSE 0, 'Medium', -1, 'Low', 'None' END AS commission_category,\n       RANK() OVER (PARTITION BY e.job_id ORDER BY e.salary DESC NULLS LAST) AS salary_rank_in_job,\n       DENSE_RANK() OVER (ORDER BY SUM(e.salary) OVER (PARTITION BY d.location_id) DESC) AS location_comp_rank\nFROM employees e\nNATURAL JOIN departments d\nJOIN locations l ON d.location_id = l.location_id\nWHERE e.hire_date BETWEEN TIMESTAMP_NTZ '2000-01-01' AND TIMESTAMP_NTZ '2023-12-31'\n  AND EXISTS (\n      SELECT 1 \n      FROM job_history jh \n      WHERE jh.employee_id = e.employee_id \n        AND jh.department_id = d.department_id\n        AND ROWNUM = 1\n  )\n  AND e.employee_id IN (\n      SELECT employee_id \n      FROM (\n          SELECT employee_id, ROW_NUMBER() OVER (ORDER BY hire_date) rn \n          FROM employees \n          WHERE department_id IS NOT NULL\n      ) \n      WHERE rn <= 50\n  )\nORDER BY d.department_name ASC NULLS FIRST, e.last_name DESC NULLS LAST;",
    "issues": [
      "The Oracle hint /*+ LEADING(e) USE_NL(d) */ is not supported in Snowflake and will be ignored; Snowflake does not support optimizer hints in this form.",
      "ROWNUM = 1 used inside the EXISTS subquery is not valid in Snowflake; ROWNUM is an Oracle-specific pseudocolumn and should be replaced with LIMIT 1 or a ROW_NUMBER() window function.",
      "The CASE statement for commission_category has incorrect syntax: 'CASE WHEN SIGN(...) THEN ... ELSE 0, ''Medium'', -1, ''Low'', ''None'' END' is malformed. It incorrectly attempts to mimic DECODE but uses invalid CASE syntax.",
      "The NATURAL JOIN in Snowflake is risky and may produce different results if column names or types differ subtly between environments; it's generally discouraged and not fully safe for migration.",
      "TIMESTAMP_NTZ '2000-01-01' is valid in Snowflake, but the original Oracle DATE literal is simpler; however, this is acceptable. Still, TIMESTAMP_NTZ is timezone-less and may differ in behavior depending on session settings.",
      "The COALESCE conversion from NVL is correct, so that part is properly handled.",
      "The DECODE function was incorrectly converted to a syntactically invalid CASE expression; it should use multiple WHEN clauses based on SIGN value.",
      "The inner subquery using ROW_NUMBER() is valid in Snowflake, so that usage is acceptable despite ROWNUM being Oracle-specific elsewhere."
    ],
    "proposed_rule": {
      "type": "regex",
      "pattern": "DECODE\\s*\\(\\s*([^,]+)\\s*,\\s*([^,]+)\\s*,\\s*([^,]+)(?:\\s*,\\s*([^,]+)\\s*,\\s*([^,]+))*\\s*\\)",
      "repl": "CASE WHEN \\1 = \\2 THEN \\3 ELSE CASE WHEN \\1 = \\4 THEN \\5 ELSE NULL END END"
    },
    "applied": false
  },
  {
    "timestamp": "2025-12-24T00:11:32.609338",
    "trigger_sql": "SELECT /*+ LEADING(e) USE_NL(d) */ \n       e.employee_id,\n       e.first_name,\n       e.last_name,\n       d.department_name,\n       NVL(TO_CHAR(e.commission_pct, 'FM0.00'), 'No Commission') AS commission_formatted,\n       CASE \n           WHEN e.salary > (SELECT AVG(salary) FROM employees WHERE department_id = e.department_id) \n           THEN 'Above Average'\n           ELSE 'Below or Equal'\n       END AS salary_level,\n       RANK() OVER (PARTITION BY e.department_id ORDER BY e.salary DESC, e.commission_pct DESC NULLS LAST) AS salary_rank_in_dept,\n       LAG(e.hire_date, 1, DATE '1900-01-01') IGNORE NULLS OVER (PARTITION BY d.location_id ORDER BY e.hire_date) AS prev_hire_date_by_location,\n       CONNECT_BY_ROOT e.manager_id AS top_manager_id,\n       SYS_CONNECT_BY_PATH(e.first_name, ' -> ') AS name_hierarchy_path\nFROM employees e\nJOIN departments d ON e.department_id = d.department_id\nLEFT JOIN locations l ON d.location_id = l.location_id(+)\nWHERE e.hire_date BETWEEN ADD_MONTHS(TRUNC(SYSDATE, 'YEAR'), -3) AND SYSDATE\n  AND e.job_id NOT IN (SELECT job_id FROM jobs WHERE job_title LIKE '%President%' OR job_title LIKE '%Admin%')\n  AND EXISTS (\n      SELECT 1 \n      FROM dual \n      WHERE DUMP(e.salary) LIKE 'Typ=2%'\n  )\nSTART WITH e.manager_id IS NULL\nCONNECT BY PRIOR e.employee_id = e.manager_id\nORDER BY d.department_name, salary_rank_in_dept;",
    "before_conversion": "SELECT /*+ LEADING(e) USE_NL(d) */ \n       e.employee_id,\n       e.first_name,\n       e.last_name,\n       d.department_name,\n       COALESCE(TO_VARCHAR(e.commission_pct, 'FM0.00'), 'No Commission') AS commission_formatted,\n       CASE \n           WHEN e.salary > (SELECT AVG(salary) FROM employees WHERE department_id = e.department_id) \n           THEN 'Above Average'\n           ELSE 'Below or Equal'\n       END AS salary_level,\n       RANK() OVER (PARTITION BY e.department_id ORDER BY e.salary DESC, e.commission_pct DESC NULLS LAST) AS salary_rank_in_dept,\n       LAG(e.hire_date, 1, TIMESTAMP_NTZ '1900-01-01') IGNORE NULLS OVER (PARTITION BY d.location_id ORDER BY e.hire_date) AS prev_hire_date_by_location,\n       CONNECT_BY_ROOT e.manager_id AS top_manager_id,\n       SYS_CONNECT_BY_PATH(e.first_name, ' -> ') AS name_hierarchy_path\nFROM employees e\nJOIN departments d ON e.department_id = d.department_id\nLEFT JOIN locations l ON d.location_id = l.location_id(+)\nWHERE e.hire_date BETWEEN DATEADD(month, CURRENT_TIMESTAMP(, DATE_TRUNC('day'), 'YEAR'), -3) AND CURRENT_TIMESTAMP()\n  AND e.job_id NOT IN (SELECT job_id FROM jobs WHERE job_title LIKE '%President%' OR job_title LIKE '%Admin%')\n  AND EXISTS (\n      SELECT 1 \n       \n      WHERE DUMP(e.salary) LIKE 'Typ=2%'\n  )\nSTART WITH e.manager_id IS NULL\nCONNECT BY PRIOR e.employee_id = e.manager_id\nORDER BY d.department_name, salary_rank_in_dept;",
    "issues": [
      "Invalid Snowflake syntax in DATEADD function: 'DATEADD(month, CURRENT_TIMESTAMP(, DATE_TRUNC('day'), 'YEAR'), -3)' is malformed. Should be 'DATEADD(month, -3, DATE_TRUNC(year, CURRENT_DATE()))'.",
      "CURRENT_TIMESTAMP() returns timestamp with time zone in Snowflake; should use CURRENT_DATE or convert appropriately for date comparison.",
      "The Oracle-specific join syntax 'l.location_id(+)' in the LEFT JOIN is not valid in Snowflake; should be standard 'LEFT JOIN locations l ON d.location_id = l.location_id'.",
      "EXISTS subquery uses DUMP(e.salary) LIKE 'Typ=2%', but DUMP() is Oracle-specific and not supported in Snowflake; this will cause an error.",
      "CONNECT_BY_ROOT and SYS_CONNECT_BY_PATH are Oracle hierarchical query clauses not natively supported in Snowflake; Snowflake requires recursive CTEs instead.",
      "START WITH and CONNECT BY are Oracle-specific hierarchical query syntax not supported in Snowflake; no equivalent logic provided.",
      "SYSDATE in Oracle converted incorrectly: TRUNC(SYSDATE, 'YEAR') becomes invalid expression in Snowflake due to incorrect DATEADD usage.",
      "Use of TIMESTAMP_NTZ '1900-01-01' is valid, but could be simplified to DATE '1900-01-01'; however, not an error.",
      "Redundant comment block in EXISTS clause with no actual condition check — appears to be a conversion mistake (empty WHERE)."
    ],
    "proposed_rule": {
      "type": "regex",
      "pattern": "(\\bWHERE\\s+e\\.hire_date\\s+BETWEEN\\s+)ADD_MONTHS\\(TRUNC\\(SYSDATE,\\s*'YEAR'\\),\\s*-3\\)(\\s+AND\\s+SYSDATE)",
      "repl": "\\1DATEADD(month, -3, DATE_TRUNC('year', CURRENT_DATE()))\\2 AND CURRENT_DATE()"
    },
    "applied": false
  }
]